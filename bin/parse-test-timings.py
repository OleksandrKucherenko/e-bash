#!/usr/bin/env python3
"""
Parse JUnit XML test reports and extract per-file timing data.

This script aggregates test execution times by spec file from JUnit XML reports
generated by ShellSpec. Output is a JSON file with timing data for chunk optimization.

Usage:
    parse-test-timings.py <output_json> <junit_xml_files...>

Example:
    parse-test-timings.py .test-timings.json report/*.xml
"""

import json
import sys
import xml.etree.ElementTree as ET
from pathlib import Path
from collections import defaultdict


def parse_junit_xml(xml_file):
    """Parse a JUnit XML file and extract test timings by spec file."""
    try:
        tree = ET.parse(xml_file)
        root = tree.getroot()
    except ET.ParseError as e:
        print(f"Warning: Failed to parse {xml_file}: {e}", file=sys.stderr)
        return {}

    timings = defaultdict(float)

    # JUnit XML can have different structures:
    # <testsuites><testsuite><testcase> or <testsuite><testcase>

    # Find all testcase elements
    for testcase in root.findall('.//testcase'):
        # Get test file from classname or name
        classname = testcase.get('classname', '')
        name = testcase.get('name', '')
        time_str = testcase.get('time', '0')

        try:
            time_val = float(time_str)
        except (ValueError, TypeError):
            time_val = 0.0

        # Extract spec file name from classname
        # ShellSpec typically uses the spec file path as classname
        # e.g., "spec/commons_spec.sh" or just "commons_spec.sh"
        spec_file = classname if classname else name

        # Normalize to relative path from project root
        if spec_file.startswith('./'):
            spec_file = spec_file[2:]
        if not spec_file.startswith('spec/'):
            # Try to extract from the name if classname is not a path
            if '.sh' in name:
                # Sometimes the spec file is in the name
                parts = name.split()
                for part in parts:
                    if part.endswith('_spec.sh'):
                        spec_file = part
                        break

        if spec_file and spec_file.endswith('.sh'):
            timings[spec_file] += time_val

    return dict(timings)


def merge_timings(all_timings):
    """Merge timing data from multiple sources, averaging when available."""
    merged = defaultdict(list)

    for timing_dict in all_timings:
        for spec_file, time_val in timing_dict.items():
            merged[spec_file].append(time_val)

    # Average the timings
    result = {}
    for spec_file, times in merged.items():
        result[spec_file] = sum(times) / len(times) if times else 0.0

    return result


def normalize_spec_path(spec_file):
    """Normalize spec file path to consistent format."""
    # Remove leading ./
    if spec_file.startswith('./'):
        spec_file = spec_file[2:]

    # Ensure it starts with spec/
    if not spec_file.startswith('spec/'):
        if spec_file.startswith('/'):
            # Extract spec/ portion from absolute path
            parts = spec_file.split('/')
            if 'spec' in parts:
                idx = parts.index('spec')
                spec_file = '/'.join(parts[idx:])
            else:
                spec_file = f"spec/{spec_file}"
        else:
            spec_file = f"spec/{spec_file}"

    return spec_file


def main():
    if len(sys.argv) < 3:
        print(f"Usage: {sys.argv[0]} <output_json> <junit_xml_files...>", file=sys.stderr)
        print(f"\nExample: {sys.argv[0]} .test-timings.json report/*.xml", file=sys.stderr)
        sys.exit(1)

    output_file = sys.argv[1]
    xml_files = sys.argv[2:]

    if not xml_files:
        print("Error: No JUnit XML files provided", file=sys.stderr)
        sys.exit(1)

    # Parse all XML files
    all_timings = []
    for xml_file in xml_files:
        if not Path(xml_file).exists():
            print(f"Warning: File not found: {xml_file}", file=sys.stderr)
            continue

        timings = parse_junit_xml(xml_file)
        if timings:
            all_timings.append(timings)

    if not all_timings:
        print("Error: No timing data extracted from XML files", file=sys.stderr)
        sys.exit(1)

    # Merge and normalize
    merged = merge_timings(all_timings)
    normalized = {normalize_spec_path(k): v for k, v in merged.items()}

    # Create output structure with metadata
    output = {
        "version": "1.0",
        "description": "Test execution timings extracted from JUnit XML reports",
        "timings": normalized,
        "total_time": sum(normalized.values()),
        "file_count": len(normalized),
        "source_files": [str(Path(f).name) for f in xml_files]
    }

    # Write JSON output
    with open(output_file, 'w') as f:
        json.dump(output, f, indent=2, sort_keys=True)

    print(f"âœ… Extracted timing data for {len(normalized)} spec files", file=sys.stderr)
    print(f"ðŸ“Š Total test time: {output['total_time']:.2f}s", file=sys.stderr)
    print(f"ðŸ’¾ Saved to: {output_file}", file=sys.stderr)

    # Print summary
    if normalized:
        print(f"\nðŸ“‹ Top 5 slowest tests:", file=sys.stderr)
        sorted_tests = sorted(normalized.items(), key=lambda x: x[1], reverse=True)
        for spec_file, time_val in sorted_tests[:5]:
            print(f"  - {spec_file}: {time_val:.2f}s", file=sys.stderr)


if __name__ == '__main__':
    main()
