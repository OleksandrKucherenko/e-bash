#!/usr/bin/env bun
/**
 * Parse JUnit XML test reports and extract per-file timing data.
 *
 * This script aggregates test execution times by spec file from JUnit XML reports
 * generated by ShellSpec. Output is a JSON file with timing data for chunk optimization.
 *
 * Usage:
 *   bun parse-test-timings.ts <output_json> <junit_xml_files...>
 *
 * Example:
 *   bun parse-test-timings.ts .test-timings.json report/*.xml
 */

import { parseStringPromise } from "xml2js";
import { readFileSync, writeFileSync } from "fs";
import { existsSync } from "fs";

interface TestCase {
  $?: {
    classname?: string;
    name?: string;
    time?: string;
  };
}

interface TestSuite {
  testcase?: TestCase[];
}

interface JUnitRoot {
  testsuite?: TestSuite;
  testsuites?: { testsuite?: TestSuite[] };
}

interface TimingData {
  [specFile: string]: number;
}

interface OutputData {
  version: string;
  description: string;
  timings: TimingData;
  total_time: number;
  file_count: number;
  source_files: string[];
}

function normalizeSpecPath(specFile: string): string {
  // Remove leading ./
  if (specFile.startsWith("./")) {
    specFile = specFile.slice(2);
  }

  // Ensure it starts with spec/
  if (!specFile.startsWith("spec/")) {
    if (specFile.startsWith("/")) {
      // Extract spec/ portion from absolute path
      const parts = specFile.split("/");
      const specIndex = parts.indexOf("spec");
      if (specIndex >= 0) {
        specFile = parts.slice(specIndex).join("/");
      } else {
        specFile = `spec/${specFile}`;
      }
    } else {
      specFile = `spec/${specFile}`;
    }
  }

  return specFile;
}

async function parseJUnitXML(xmlFile: string): Promise<TimingData> {
  const timings: TimingData = {};

  try {
    if (!existsSync(xmlFile)) {
      console.error(`Warning: File not found: ${xmlFile}`);
      return timings;
    }

    const xmlContent = readFileSync(xmlFile, "utf-8");
    const result: JUnitRoot = await parseStringPromise(xmlContent);

    // Extract all testcase elements
    const testcases: TestCase[] = [];

    if (result.testsuite?.testcase) {
      testcases.push(...result.testsuite.testcase);
    }

    if (result.testsuites?.testsuite) {
      for (const suite of result.testsuites.testsuite) {
        if (suite.testcase) {
          testcases.push(...suite.testcase);
        }
      }
    }

    // Process each test case
    for (const testcase of testcases) {
      const classname = testcase.$?.classname || "";
      const name = testcase.$?.name || "";
      const timeStr = testcase.$?.time || "0";

      let timeVal = parseFloat(timeStr);
      if (isNaN(timeVal)) {
        timeVal = 0;
      }

      // Extract spec file from classname or name
      let specFile = classname || name;

      // Sometimes the spec file is in the name if classname is not a path
      if (specFile && !specFile.endsWith(".sh")) {
        const parts = name.split(/\s+/);
        for (const part of parts) {
          if (part.endsWith("_spec.sh")) {
            specFile = part;
            break;
          }
        }
      }

      if (specFile && specFile.endsWith(".sh")) {
        const normalized = normalizeSpecPath(specFile);
        timings[normalized] = (timings[normalized] || 0) + timeVal;
      }
    }
  } catch (error) {
    console.error(`Warning: Failed to parse ${xmlFile}:`, error);
  }

  return timings;
}

function mergeTimings(allTimings: TimingData[]): TimingData {
  const merged: { [key: string]: number[] } = {};

  for (const timingDict of allTimings) {
    for (const [specFile, timeVal] of Object.entries(timingDict)) {
      if (!merged[specFile]) {
        merged[specFile] = [];
      }
      merged[specFile].push(timeVal);
    }
  }

  // Average the timings
  const result: TimingData = {};
  for (const [specFile, times] of Object.entries(merged)) {
    result[specFile] = times.reduce((a, b) => a + b, 0) / times.length;
  }

  return result;
}

async function main() {
  const args = process.argv.slice(2);

  if (args.length < 2) {
    console.error(`Usage: bun parse-test-timings.ts <output_json> <junit_xml_files...>`);
    console.error(`\nExample: bun parse-test-timings.ts .test-timings.json report/*.xml`);
    process.exit(1);
  }

  const outputFile = args[0];
  const xmlFiles = args.slice(1);

  if (xmlFiles.length === 0) {
    console.error("Error: No JUnit XML files provided");
    process.exit(1);
  }

  // Parse all XML files
  const allTimings: TimingData[] = [];
  for (const xmlFile of xmlFiles) {
    const timings = await parseJUnitXML(xmlFile);
    if (Object.keys(timings).length > 0) {
      allTimings.push(timings);
    }
  }

  if (allTimings.length === 0) {
    console.error("Error: No timing data extracted from XML files");
    process.exit(1);
  }

  // Merge and create output
  const merged = mergeTimings(allTimings);
  const totalTime = Object.values(merged).reduce((a, b) => a + b, 0);

  const output: OutputData = {
    version: "1.0",
    description: "Test execution timings extracted from JUnit XML reports",
    timings: merged,
    total_time: totalTime,
    file_count: Object.keys(merged).length,
    source_files: xmlFiles.map((f) => f.split("/").pop() || f),
  };

  // Write JSON output
  writeFileSync(outputFile, JSON.stringify(output, null, 2));

  console.error(`âœ… Extracted timing data for ${Object.keys(merged).length} spec files`);
  console.error(`ðŸ“Š Total test time: ${totalTime.toFixed(2)}s`);
  console.error(`ðŸ’¾ Saved to: ${outputFile}`);

  // Print summary
  const sorted = Object.entries(merged).sort((a, b) => b[1] - a[1]);
  console.error(`\nðŸ“‹ Top 5 slowest tests:`);
  for (let i = 0; i < Math.min(5, sorted.length); i++) {
    const [file, time] = sorted[i];
    console.error(`  - ${file}: ${time.toFixed(2)}s`);
  }
}

main().catch((error) => {
  console.error("Fatal error:", error);
  process.exit(1);
});
