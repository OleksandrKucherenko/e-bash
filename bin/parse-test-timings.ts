#!/usr/bin/env bun
/**
 * Parse JUnit XML test reports and extract per-file timing data.
 *
 * This script aggregates test execution times by spec file from JUnit XML reports
 * generated by ShellSpec. Output is a JSON file with timing data for chunk optimization.
 *
 * Usage:
 *   bun parse-test-timings.ts <output_json> <junit_xml_files...>
 *
 * Example:
 *   bun parse-test-timings.ts .test-timings.json report/*.xml
 */

import { readFileSync, writeFileSync, existsSync } from "fs";

interface TimingData {
  [specFile: string]: number;
}

interface OutputData {
  version: string;
  description: string;
  timings: TimingData;
  total_time: number;
  file_count: number;
  source_files: string[];
}

function normalizeSpecPath(specFile: string): string {
  // Remove leading ./
  if (specFile.startsWith("./")) {
    specFile = specFile.slice(2);
  }

  // Ensure it starts with spec/
  if (!specFile.startsWith("spec/")) {
    if (specFile.startsWith("/")) {
      // Extract spec/ portion from absolute path
      const parts = specFile.split("/");
      const specIndex = parts.indexOf("spec");
      if (specIndex >= 0) {
        specFile = parts.slice(specIndex).join("/");
      } else {
        specFile = `spec/${specFile}`;
      }
    } else {
      specFile = `spec/${specFile}`;
    }
  }

  return specFile;
}

function parseJUnitXML(xmlFile: string): TimingData {
  const timings: TimingData = {};

  try {
    if (!existsSync(xmlFile)) {
      console.error(`Warning: File not found: ${xmlFile}`);
      return timings;
    }

    const xmlContent = readFileSync(xmlFile, "utf-8");

    // Simple regex-based parsing - no dependencies needed
    // Match testcase elements with time attribute
    // Format: <testcase classname="..." name="..." time="..."/>
    const testcaseRegex = /<testcase[^>]*>/g;
    const matches = xmlContent.match(testcaseRegex);

    if (!matches) {
      console.error(`Warning: No testcase elements found in ${xmlFile}`);
      return timings;
    }

    for (const testcaseTag of matches) {
      // Extract attributes
      const classnameMatch = testcaseTag.match(/classname="([^"]*)"/);
      const nameMatch = testcaseTag.match(/name="([^"]*)"/);
      const timeMatch = testcaseTag.match(/time="([^"]*)"/);

      const classname = classnameMatch ? classnameMatch[1] : "";
      const name = nameMatch ? nameMatch[1] : "";
      const timeStr = timeMatch ? timeMatch[1] : "0";

      let timeVal = parseFloat(timeStr);
      if (isNaN(timeVal)) {
        timeVal = 0;
      }

      // Extract spec file from classname or name
      let specFile = classname || name;

      // Sometimes the spec file is in the name if classname is not a path
      if (specFile && !specFile.endsWith(".sh")) {
        const parts = name.split(/\s+/);
        for (const part of parts) {
          if (part.endsWith("_spec.sh")) {
            specFile = part;
            break;
          }
        }
      }

      if (specFile && specFile.endsWith(".sh")) {
        const normalized = normalizeSpecPath(specFile);
        timings[normalized] = (timings[normalized] || 0) + timeVal;
      }
    }

    // Also try to extract from testsuite time attribute as fallback
    // Format: <testsuite name="spec/file.sh" time="...">
    const testsuiteRegex = /<testsuite[^>]*>/g;
    const suiteMatches = xmlContent.match(testsuiteRegex);

    if (suiteMatches) {
      for (const suiteTag of suiteMatches) {
        const nameMatch = suiteTag.match(/name="([^"]*)"/);
        const timeMatch = suiteTag.match(/time="([^"]*)"/);

        if (nameMatch && timeMatch) {
          const specFile = nameMatch[1];
          const timeStr = timeMatch[1];
          const timeVal = parseFloat(timeStr);

          if (!isNaN(timeVal) && timeVal > 0 && specFile.endsWith(".sh")) {
            const normalized = normalizeSpecPath(specFile);
            // Only use testsuite time if we don't have testcase times
            if (!timings[normalized] || timings[normalized] === 0) {
              timings[normalized] = timeVal;
            }
          }
        }
      }
    }
  } catch (error) {
    console.error(`Warning: Failed to parse ${xmlFile}:`, error);
  }

  return timings;
}

function mergeTimings(allTimings: TimingData[]): TimingData {
  const merged: { [key: string]: number[] } = {};

  for (const timingDict of allTimings) {
    for (const [specFile, timeVal] of Object.entries(timingDict)) {
      if (!merged[specFile]) {
        merged[specFile] = [];
      }
      merged[specFile].push(timeVal);
    }
  }

  // Average the timings
  const result: TimingData = {};
  for (const [specFile, times] of Object.entries(merged)) {
    result[specFile] = times.reduce((a, b) => a + b, 0) / times.length;
  }

  return result;
}

async function main() {
  const args = process.argv.slice(2);

  if (args.length < 2) {
    console.error(`Usage: bun parse-test-timings.ts <output_json> <junit_xml_files...>`);
    console.error(`\nExample: bun parse-test-timings.ts .test-timings.json report/*.xml`);
    process.exit(1);
  }

  const outputFile = args[0];
  const xmlFiles = args.slice(1);

  if (xmlFiles.length === 0) {
    console.error("Error: No JUnit XML files provided");
    process.exit(1);
  }

  // Parse all XML files
  const allTimings: TimingData[] = [];
  for (const xmlFile of xmlFiles) {
    const timings = parseJUnitXML(xmlFile);
    if (Object.keys(timings).length > 0) {
      allTimings.push(timings);
    }
  }

  if (allTimings.length === 0) {
    console.error("Error: No timing data extracted from XML files");
    process.exit(1);
  }

  // Merge and create output
  const merged = mergeTimings(allTimings);
  const totalTime = Object.values(merged).reduce((a, b) => a + b, 0);

  const output: OutputData = {
    version: "1.0",
    description: "Test execution timings extracted from JUnit XML reports",
    timings: merged,
    total_time: totalTime,
    file_count: Object.keys(merged).length,
    source_files: xmlFiles.map((f) => f.split("/").pop() || f),
  };

  // Write JSON output
  writeFileSync(outputFile, JSON.stringify(output, null, 2));

  console.error(`âœ… Extracted timing data for ${Object.keys(merged).length} spec files`);
  console.error(`ðŸ“Š Total test time: ${totalTime.toFixed(2)}s`);
  console.error(`ðŸ’¾ Saved to: ${outputFile}`);

  // Print summary
  const sorted = Object.entries(merged).sort((a, b) => b[1] - a[1]);
  console.error(`\nðŸ“‹ Top 5 slowest tests:`);
  for (let i = 0; i < Math.min(5, sorted.length); i++) {
    const [file, time] = sorted[i];
    console.error(`  - ${file}: ${time.toFixed(2)}s`);
  }
}

main().catch((error) => {
  console.error("Fatal error:", error);
  process.exit(1);
});
