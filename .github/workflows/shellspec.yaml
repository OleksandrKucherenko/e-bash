name: "Shellspec"

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

env:
  SHELLSPEC_VERSION: 0.28.1
  TERM: xterm-256color
  HOMEBREW_NO_AUTO_UPDATE: 1
  HOMEBREW_NO_INSTALL_CLEANUP: 1
  HOMEBREW_NO_ENV_HINTS: 1
  # Enable CI auto-install mode for dependencies
  CI_E_BASH_INSTALL_DEPENDENCIES: 1

jobs:
  shellspec-macos:
    name: "MacOS (chunk ${{ matrix.chunk }})"
    runs-on: macos-latest
    if: "!contains(github.event.head_commit.message, 'ci skip')"
    strategy:
      fail-fast: false
      matrix:
        chunk: [0, 1, 2, 3]
    steps:
      - name: Checkout Code with full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0   # Full history needed for release-it to generate proper changelog
          fetch-tags: true # For correct version detection by release-it

      - name: Restore test timing cache
        uses: actions/cache@v4
        with:
          path: .test-timings.json
          key: test-timings-${{ runner.os }}-${{ github.sha }}
          restore-keys: |
            test-timings-${{ runner.os }}-
            test-timings-

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install dependencies for timing scripts
        run: bun install

      - name: Detect Homebrew Path
        id: brew_path
        shell: bash
        run: |
          if [[ "$RUNNER_OS" == "Linux" ]]; then
            echo "path=/home/linuxbrew/.linuxbrew" >> "$GITHUB_OUTPUT"
            echo "cache_dir=/home/runner/.cache/Homebrew" >> "$GITHUB_OUTPUT"
          else
            if [ -d "/opt/homebrew" ]; then
              echo "path=/opt/homebrew" >> "$GITHUB_OUTPUT"
            else
              echo "path=/usr/local/Homebrew" >> "$GITHUB_OUTPUT"
            fi
            echo "cache_dir=$HOME/Library/Caches/Homebrew" >> "$GITHUB_OUTPUT"
          fi

      - name: Verify Files and Folders
        id: hashes
        shell: bash
        run: |
          ls -la .
          pwd
          shasum -a 256 .envrc
          shasum -a 256 .envrc | cut -c1-8
          echo "sha256=$(shasum -a 256 .envrc | cut -c1-8)" >> $GITHUB_OUTPUT

      - name: Check Homebrew cache size
        id: cache_check
        shell: bash
        run: |
          # Check if Homebrew directories exist and their size
          MAX_SIZE_MB=300
          TOTAL_SIZE=0

          if [ -d "${{ steps.brew_path.outputs.path }}" ]; then
            BREW_SIZE=$(du -sm "${{ steps.brew_path.outputs.path }}" 2>/dev/null | cut -f1 || echo "0")
            TOTAL_SIZE=$((TOTAL_SIZE + BREW_SIZE))
            echo "Homebrew path size: ${BREW_SIZE}MB"
          fi

          if [ -d "${{ steps.brew_path.outputs.cache_dir }}" ]; then
            CACHE_SIZE=$(du -sm "${{ steps.brew_path.outputs.cache_dir }}" 2>/dev/null | cut -f1 || echo "0")
            TOTAL_SIZE=$((TOTAL_SIZE + CACHE_SIZE))
            echo "Homebrew cache size: ${CACHE_SIZE}MB"
          fi

          echo "Total Homebrew size: ${TOTAL_SIZE}MB"
          echo "Maximum allowed size: ${MAX_SIZE_MB}MB"

          if [ "$TOTAL_SIZE" -le "$MAX_SIZE_MB" ]; then
            echo "âœ… Homebrew size is within limits, caching enabled"
            echo "should_cache=true" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸  Homebrew size exceeds ${MAX_SIZE_MB}MB, caching disabled to avoid inefficiency"
            echo "should_cache=false" >> $GITHUB_OUTPUT
          fi

      - name: Cache Homebrew packages
        if: steps.cache_check.outputs.should_cache == 'true'
        uses: actions/cache@v4
        with:
          path: |
            ${{ steps.brew_path.outputs.path }}
            ${{ steps.brew_path.outputs.cache_dir }}
          key: brew-${{ runner.os }}-${{ steps.hashes.outputs.sha256 }}
          restore-keys: |
            brew-${{ runner.os }}-

      - name: Add Homebrew to PATH
        shell: bash
        run: |
          echo "${{ steps.brew_path.outputs.path }}/bin" >> $GITHUB_PATH

      - name: Setup PATH for local binaries
        run: |
          echo "${HOME}/.local/bin" >> "$GITHUB_PATH"
          mkdir -p "${HOME}/.local/bin"

      - name: Install DIRENV
        run: |
          # Install direnv for macOS
          brew install direnv

      - name: Verify installation order and setup
        run: |
          # Verify critical tools are available in correct order
          echo "=== Verifying installation order ==="
          echo "1. Homebrew: $(which brew || echo 'NOT FOUND')"
          echo "2. DIRENV: $(which direnv || echo 'NOT FOUND')"
          echo "3. Homebrew available: $(brew --help >/dev/null 2>&1 && echo 'YES' || echo 'NO')"
          echo "4. DIRENV version: $(direnv version || echo 'FAILED')"

      - name: Setup project dependencies using DIRENV and CI auto-install mode
        run: |
          # Allow .envrc execution and export environment to GitHub Actions
          direnv allow .
          direnv export gha >> "$GITHUB_ENV"
          echo "Dependencies loaded via DIRENV with CI auto-install mode"
          brew cleanup

      - name: Run shellspec Tests (chunk ${{ matrix.chunk }})
        run: |
          # Get test files for this chunk
          CHUNK_FILES=$(./bin/chunk-tests.sh 4 ${{ matrix.chunk }})

          if [ -z "$CHUNK_FILES" ]; then
            echo "No test files for chunk ${{ matrix.chunk }}"
            exit 0
          fi

          echo "Running tests for chunk ${{ matrix.chunk }}:"
          echo "$CHUNK_FILES"
          echo ""

          # Environment variables from .envrc are now available
          # Note: shellspec 0.28.1 has a bug with pop_var_context that causes exit code 102
          # even when all tests pass. We capture output and check for successful test completion.
          # Using tee to save output to log file while displaying it
          set -o pipefail  # Make pipe return first non-zero exit code
          shellspec $CHUNK_FILES 2>&1 | tee /tmp/test_output.txt || {
            exit_code=${PIPESTATUS[0]}  # Get shellspec exit code, not tee's
            echo "Shellspec exited with code $exit_code, checking if tests actually passed..."

            # Dynamic test validation (no hardcoded test counts)
            # Check: 1) At least one test passed, 2) No failures, 3) Summary shows success
            passed_tests=$(grep -c "^ok " /tmp/test_output.txt || true)
            failed_tests=$(grep -c "^not ok " /tmp/test_output.txt || true)
            has_summary=$(grep -q "examples, .* failures" /tmp/test_output.txt && echo "yes" || echo "no")

            if [ "$passed_tests" -gt 0 ] && [ "$failed_tests" -eq 0 ] && [ "$has_summary" = "yes" ]; then
              echo "âœ… All $passed_tests tests passed (0 failures) - ignoring shellspec exit code bug"
              exit 0
            else
              echo "âŒ Tests actually failed or incomplete"
              echo "   Passed: $passed_tests, Failed: $failed_tests, Has summary: $has_summary"
              exit 1
            fi
          }

      - name: Display failed tests summary
        if: always()
        run: |
          if [ -f /tmp/test_output.txt ]; then
            failed=$(grep "^not ok " /tmp/test_output.txt || true)
            if [ -n "$failed" ]; then
              echo ""
              echo "================================================"
              echo "âŒ FAILED TESTS SUMMARY"
              echo "================================================"
              echo "$failed"
              echo "================================================"
            else
              echo ""
              echo "âœ… All tests passed!"
            fi
          fi
  
  shellspec-ubuntu:
    name: "Ubuntu (chunk ${{ matrix.chunk }})"
    # kcov only works on ubuntu 22.04, on ubuntu-latest installation fails
    runs-on: ubuntu-22.04
    if: "!contains(github.event.head_commit.message, 'ci skip')"
    strategy:
      fail-fast: false
      matrix:
        chunk: [0, 1, 2, 3]
    steps:
      - name: Checkout Code with full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0   # Full history needed for release-it to generate proper changelog
          fetch-tags: true # For correct version detection by release-it

      - name: Fetch PR base branch for coverage comparison
        if: github.event_name == 'pull_request'
        run: |
          # Fetch the base branch to enable Codecov comparison
          git fetch origin ${{ github.base_ref }}:${{ github.base_ref }}
          echo "Base branch ${{ github.base_ref }} fetched for coverage comparison"

      - name: Restore test timing cache
        uses: actions/cache@v4
        with:
          path: .test-timings.json
          key: test-timings-${{ runner.os }}-${{ github.sha }}
          restore-keys: |
            test-timings-${{ runner.os }}-
            test-timings-

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install dependencies for timing scripts
        run: bun install

      - name: Detect Homebrew Path
        id: brew_path
        shell: bash
        run: |
          if [[ "$RUNNER_OS" == "Linux" ]]; then
            echo "path=/home/linuxbrew/.linuxbrew" >> "$GITHUB_OUTPUT"
            echo "cache_dir=/home/runner/.cache/Homebrew" >> "$GITHUB_OUTPUT"
          else
            if [ -d "/opt/homebrew" ]; then
              echo "path=/opt/homebrew" >> "$GITHUB_OUTPUT"
            else
              echo "path=/usr/local/Homebrew" >> "$GITHUB_OUTPUT"
            fi
            echo "cache_dir=$HOME/Library/Caches/Homebrew" >> "$GITHUB_OUTPUT"
          fi

      - name: Setup PATH for local binaries
        run: |
          echo "${HOME}/.local/bin" >> "$GITHUB_PATH"
          mkdir -p "${HOME}/.local/bin"

      - name: Verify Files and Folders
        id: hashes
        shell: bash
        run: |
          ls -la .
          pwd
          shasum -a 256 .envrc
          shasum -a 256 .envrc | cut -c1-8
          echo "sha256=$(shasum -a 256 .envrc | cut -c1-8)" >> $GITHUB_OUTPUT

      - name: Check Homebrew cache size
        id: cache_check
        shell: bash
        run: |
          # Check if Homebrew directories exist and their size
          MAX_SIZE_MB=300
          TOTAL_SIZE=0

          if [ -d "${{ steps.brew_path.outputs.path }}" ]; then
            BREW_SIZE=$(du -sm "${{ steps.brew_path.outputs.path }}" 2>/dev/null | cut -f1 || echo "0")
            TOTAL_SIZE=$((TOTAL_SIZE + BREW_SIZE))
            echo "Homebrew path size: ${BREW_SIZE}MB"
          fi

          if [ -d "${{ steps.brew_path.outputs.cache_dir }}" ]; then
            CACHE_SIZE=$(du -sm "${{ steps.brew_path.outputs.cache_dir }}" 2>/dev/null | cut -f1 || echo "0")
            TOTAL_SIZE=$((TOTAL_SIZE + CACHE_SIZE))
            echo "Homebrew cache size: ${CACHE_SIZE}MB"
          fi

          echo "Total Homebrew size: ${TOTAL_SIZE}MB"
          echo "Maximum allowed size: ${MAX_SIZE_MB}MB"

          if [ "$TOTAL_SIZE" -le "$MAX_SIZE_MB" ]; then
            echo "âœ… Homebrew size is within limits, caching enabled"
            echo "should_cache=true" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸  Homebrew size exceeds ${MAX_SIZE_MB}MB, caching disabled to avoid inefficiency"
            echo "should_cache=false" >> $GITHUB_OUTPUT
          fi

      - name: Cache Homebrew packages
        if: steps.cache_check.outputs.should_cache == 'true'
        uses: actions/cache@v4
        with:
          path: |
            ${{ steps.brew_path.outputs.path }}
            ${{ steps.brew_path.outputs.cache_dir }}
          key: brew-${{ runner.os }}-${{ steps.hashes.outputs.sha256 }}
          restore-keys: |
            brew-${{ runner.os }}-

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y kcov uuid-runtime curl build-essential procps file git
      - name: Install Homebrew (Linux only)
        run: |
          # Check if Homebrew is already installed (from cache)
          if [ ! -x ${{ steps.brew_path.outputs.path }}/bin/brew ]; then
            echo "Installing Homebrew for Linux..."
            NONINTERACTIVE=1 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
          else
            echo "Homebrew found in cache, skipping installation"
          fi

      - name: Add Homebrew to PATH
        shell: bash
        run: |
          echo "${{ steps.brew_path.outputs.path }}/bin" >> $GITHUB_PATH
          # Set up Homebrew environment variables
          eval "$(${{ steps.brew_path.outputs.path }}/bin/brew shellenv)"
          echo "HOMEBREW_PREFIX=${{ steps.brew_path.outputs.path }}" >> "$GITHUB_ENV"
          echo "HOMEBREW_CELLAR=${{ steps.brew_path.outputs.path }}/Cellar" >> "$GITHUB_ENV"
          echo "HOMEBREW_REPOSITORY=${{ steps.brew_path.outputs.path }}/Homebrew" >> "$GITHUB_ENV"

      - name: Install DIRENV
        run: |
          # Install direnv for Ubuntu (must be after Homebrew for dependency order)
          curl -sfL https://direnv.net/install.sh | bash
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"

      - name: Verify installation order and setup
        run: |
          # Verify critical tools are available in correct order
          echo "=== Verifying installation order ==="
          echo "1. Homebrew: $(which brew || echo 'NOT FOUND')"
          echo "2. DIRENV: $(which direnv || echo 'NOT FOUND')"
          echo "3. Homebrew available: $(brew --help >/dev/null 2>&1 && echo 'YES' || echo 'NO')"
          echo "4. DIRENV version: $(direnv version || echo 'FAILED')"

      - name: Setup project dependencies using DIRENV and CI auto-install mode
        run: |
          # Ensure Homebrew is in PATH for this step
          eval "$(${{ steps.brew_path.outputs.path }}/bin/brew shellenv)"
          # Allow .envrc execution and export environment to GitHub Actions
          direnv allow .
          direnv export gha >> "$GITHUB_ENV"
          echo "Dependencies loaded via DIRENV with CI auto-install mode"
          brew cleanup

      - name: Run shellspec tests with coverage (chunk ${{ matrix.chunk }})
        run: |
          # Get test files for this chunk
          CHUNK_FILES=$(./bin/chunk-tests.sh 4 ${{ matrix.chunk }})

          if [ -z "$CHUNK_FILES" ]; then
            echo "No test files for chunk ${{ matrix.chunk }}"
            exit 0
          fi

          echo "Running tests for chunk ${{ matrix.chunk }}:"
          echo "$CHUNK_FILES"
          echo ""

          # Environment variables from .envrc are now available (includes GNU tools setup)
          # Run with kcov to generate coverage reports
          # Note: shellspec 0.28.1 has a bug with pop_var_context that causes exit code 102
          # even when all tests pass. We capture output and check for successful test completion.
          # Using tee to save output to log file while displaying it
          set -o pipefail  # Make pipe return first non-zero exit code
          shellspec --kcov $CHUNK_FILES 2>&1 | tee /tmp/test_output.txt || {
            exit_code=${PIPESTATUS[0]}  # Get shellspec exit code, not tee's
            echo "Shellspec exited with code $exit_code, checking if tests actually passed..."

            # Dynamic test validation (no hardcoded test counts)
            # Check: 1) At least one test passed, 2) No failures, 3) Summary shows success
            passed_tests=$(grep -c "^ok " /tmp/test_output.txt || true)
            failed_tests=$(grep -c "^not ok " /tmp/test_output.txt || true)
            has_summary=$(grep -q "examples, .* failures" /tmp/test_output.txt && echo "yes" || echo "no")

            if [ "$passed_tests" -gt 0 ] && [ "$failed_tests" -eq 0 ] && [ "$has_summary" = "yes" ]; then
              echo "âœ… All $passed_tests tests passed (0 failures) - ignoring shellspec exit code bug"
              exit 0
            else
              echo "âŒ Tests actually failed or incomplete"
              echo "   Passed: $passed_tests, Failed: $failed_tests, Has summary: $has_summary"
              exit 1
            fi
          }

      - name: Display failed tests summary
        if: always()
        run: |
          if [ -f /tmp/test_output.txt ]; then
            failed=$(grep "^not ok " /tmp/test_output.txt || true)
            if [ -n "$failed" ]; then
              echo ""
              echo "================================================"
              echo "âŒ FAILED TESTS SUMMARY"
              echo "================================================"
              echo "$failed"
              echo "================================================"
            else
              echo ""
              echo "âœ… All tests passed!"
            fi
          fi

      - name: Generate coverage summary
        if: always()
        run: |
          # Extract coverage percentage from cobertura.xml
          if [ -f coverage/cobertura.xml ]; then
            coverage=$(grep -oP 'line-rate="\K[0-9.]+' coverage/cobertura.xml | head -1 | awk '{printf "%.1f%%", $1*100}')
            echo "## ðŸ“Š Code Coverage Report (chunk ${{ matrix.chunk }})" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Line Coverage (partial):** $coverage" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ“ Full HTML report available in workflow artifacts" >> $GITHUB_STEP_SUMMARY
            echo "â„¹ï¸ Complete coverage shown in Codecov after all chunks complete" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ Coverage report not generated for chunk ${{ matrix.chunk }}" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload coverage to Codecov
        if: always()
        uses: codecov/codecov-action@v4
        with:
          files: ./coverage/cobertura.xml
          flags: shellspec-ubuntu,chunk-${{ matrix.chunk }}
          name: shellspec-ubuntu-22.04-chunk-${{ matrix.chunk }}
          fail_ci_if_error: false
          verbose: true
          # Override branch detection for master branch pushes
          override_branch: ${{ github.ref_name }}
          override_commit: ${{ github.sha }}
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

      - name: Upload coverage HTML report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report-ubuntu-chunk-${{ matrix.chunk }}
          path: coverage/
          retention-days: 30

      - name: Upload test results to Codecov
        if: ${{ !cancelled() }}
        uses: codecov/test-results-action@v1
        with:
          token: ${{ secrets.CODECOV_TOKEN }}

      - name: Upload test results as artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-ubuntu-chunk-${{ matrix.chunk }}
          path: report/
          retention-days: 30

      - name: Update test timing cache
        if: success()
        run: |
          # Parse JUnit XML reports and update timing data
          if [ -d report ] && ls report/*.xml >/dev/null 2>&1; then
            echo "ðŸ“Š Parsing test timing data from JUnit XML..."
            bun bin/parse-test-timings.ts .test-timings.json report/*.xml || {
              echo "âš ï¸  Failed to parse timing data, keeping existing cache"
            }
          else
            echo "âš ï¸  No JUnit XML reports found, skipping timing update"
          fi

  shellmetrics:
    name: "Code Metrics"
    runs-on: ubuntu-latest
    if: "!contains(github.event.head_commit.message, 'ci skip')"
    permissions:
      pull-requests: write
      contents: read
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup PATH for local binaries
        run: |
          echo "${HOME}/.local/bin" >> "$GITHUB_PATH"
          mkdir -p "${HOME}/.local/bin"

      - name: Install ShellMetrics
        run: |
          curl -fsSL https://raw.githubusercontent.com/shellspec/shellmetrics/master/shellmetrics > "${HOME}/.local/bin/shellmetrics"
          chmod +x "${HOME}/.local/bin/shellmetrics"
          shellmetrics --help || echo "ShellMetrics installed"

      - name: Collect current branch metrics
        run: |
          ./bin/shellmetrics-compare.sh collect current-metrics.csv

      - name: Collect base branch metrics (PR only)
        if: github.event_name == 'pull_request'
        run: |
          # Use git worktree to checkout base branch in separate directory
          git worktree add --detach /tmp/base-branch origin/${{ github.base_ref }}

          # Copy the script to the worktree (it might not exist in base branch)
          cp ./bin/shellmetrics-compare.sh /tmp/base-branch/

          # Collect metrics from base branch
          cd /tmp/base-branch
          ./shellmetrics-compare.sh collect /tmp/base-metrics.csv

          # Clean up worktree (force to ignore our copied script)
          cd -
          git worktree remove --force /tmp/base-branch

      - name: Generate metrics comparison report
        if: github.event_name == 'pull_request'
        run: |
          ./bin/shellmetrics-compare.sh compare /tmp/base-metrics.csv current-metrics.csv metrics-report.md

          # Add commit info to the report
          BASE_SHA=$(git rev-parse origin/${{ github.base_ref }})
          CURRENT_SHA="${{ github.sha }}"
          echo "" >> metrics-report.md
          echo "**Base:** \`${{ github.base_ref }}\` @ [\`${BASE_SHA:0:8}\`](https://github.com/${{ github.repository }}/commit/${BASE_SHA})" >> metrics-report.md
          echo "**Current:** \`${{ github.head_ref }}\` @ [\`${CURRENT_SHA:0:8}\`](https://github.com/${{ github.repository }}/commit/${CURRENT_SHA})" >> metrics-report.md

          echo "### Metrics Report" >> $GITHUB_STEP_SUMMARY
          cat metrics-report.md >> $GITHUB_STEP_SUMMARY

      - name: Post PR comment with metrics
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const reportPath = 'metrics-report.md';

            if (!fs.existsSync(reportPath)) {
              console.log('Metrics report not found, skipping PR comment');
              return;
            }

            const report = fs.readFileSync(reportPath, 'utf8');

            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('ðŸ“Š ShellMetrics Code Complexity Report')
            );

            const commentBody = report;

            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: commentBody
              });
              console.log('Updated existing metrics comment');
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: commentBody
              });
              console.log('Created new metrics comment');
            }

      - name: Upload metrics artifacts (push events)
        if: always() && github.event_name == 'push'
        uses: actions/upload-artifact@v4
        with:
          name: shellmetrics-reports
          path: current-metrics.csv
          retention-days: 30

      - name: Upload metrics artifacts (PR events)
        if: always() && github.event_name == 'pull_request'
        uses: actions/upload-artifact@v4
        with:
          name: shellmetrics-reports
          path: |
            current-metrics.csv
            /tmp/base-metrics.csv
            metrics-report.md
          retention-days: 30
