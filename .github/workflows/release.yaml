name: "Release Distribution"

on:
  push:
    tags:
      - 'v*' # Trigger on any tag starting with 'v' (e.g., v1.0.0, v1.0.0-alpha, v1.0.0-beta.1+meta)

  # Allows manual workflow dispatch for testing releases
  workflow_dispatch:
    inputs:
      tag:
        description: 'Version tag (e.g., v1.2.3)'
        required: true
        type: string

env:
  TERM: xterm-256color
  HOMEBREW_NO_AUTO_UPDATE: 1
  HOMEBREW_NO_INSTALL_CLEANUP: 1
  HOMEBREW_NO_ENV_HINTS: 1

jobs:
  create-release:
    name: "Create Release"
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Extract version from tag
        id: version
        run: |
          # Handle both push and workflow_dispatch events
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            TAG_NAME="${{ github.event.inputs.tag }}"
          else
            TAG_NAME="${GITHUB_REF#refs/tags/}"
          fi

          # Extract version from tag (remove 'v' prefix)
          VERSION="${TAG_NAME#v}"
          echo "tag=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "üì¶ Building release for version: $VERSION (tag: $TAG_NAME)"

      - name: Validate semver format
        id: validate
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG="${{ steps.version.outputs.tag }}"

          echo "üîç Validating semver format for: $VERSION"

          # Semver regex pattern (supports major.minor.patch with optional pre-release and build metadata)
          # Examples: 1.0.0, 1.0.0-alpha, 1.0.0-beta.1, 1.0.0+meta, 1.0.0-rc.1+build.123
          SEMVER_REGEX='^[0-9]+\.[0-9]+\.[0-9]+(-[0-9A-Za-z.-]+)?(\+[0-9A-Za-z.-]+)?$'

          if [[ ! "$VERSION" =~ $SEMVER_REGEX ]]; then
            echo "‚ùå ERROR: Tag '$TAG' does not follow semantic versioning format"
            echo "Expected format: vMAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]"
            echo "Examples: v1.0.0, v1.0.0-alpha, v1.0.0-beta.1, v1.0.0-rc.1+build.123"

            # Write error to GitHub step summary
            cat >> $GITHUB_STEP_SUMMARY << EOF
          ## ‚ùå Release Validation Failed

          **Tag:** \`$TAG\`
          **Version:** \`$VERSION\`

          ### Issue
          Tag does not follow semantic versioning format.

          ### Expected Format
          \`vMAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]\`

          ### Valid Examples
          - \`v1.0.0\` - Standard release
          - \`v1.0.0-alpha\` - Pre-release
          - \`v1.0.0-beta.1\` - Pre-release with number
          - \`v1.0.0-rc.1+build.123\` - Pre-release with build metadata

          ### Action Required
          Please create a new tag following the semver format.
          EOF

            echo "is_valid=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "‚úÖ Valid semver format: $VERSION"
          echo "is_valid=true" >> $GITHUB_OUTPUT

      - name: Run ShellCheck on core scripts
        if: steps.validate.outputs.is_valid == 'true'
        continue-on-error: true
        run: |
          echo "üîç Running ShellCheck on .scripts/ and bin/ directories..."

          # Check if shellcheck is available
          if ! command -v shellcheck &> /dev/null; then
            echo "‚ö†Ô∏è  ShellCheck not found, installing..."
            sudo apt-get update
            sudo apt-get install -y shellcheck
          fi

          # Run shellcheck on all shell scripts (SC1091=source file not found, SC2086=word splitting)
          EXIT_CODE=0
          while IFS= read -r file; do
            echo "Checking: $file"
            if ! shellcheck -e SC1091 -e SC2086 "$file"; then
              EXIT_CODE=1
            fi
          done < <(find .scripts bin -type f -name "*.sh")

          if [ $EXIT_CODE -eq 0 ]; then
            echo "‚úÖ All shell scripts passed ShellCheck"
          else
            echo "‚ö†Ô∏è  Some ShellCheck warnings found (non-blocking)"
            exit 0  # Don't fail the workflow
          fi

      - name: Delete existing release if tag was reassigned
        if: steps.validate.outputs.is_valid == 'true'
        continue-on-error: true
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          echo "üîç Checking for existing release: $TAG"

          # Check if release exists and delete it
          if gh release view "$TAG" &>/dev/null; then
            echo "üóëÔ∏è  Deleting existing release for tag: $TAG"
            gh release delete "$TAG" --yes --cleanup-tag || true
            echo "‚úÖ Existing release deleted"
          else
            echo "‚ÑπÔ∏è  No existing release found for tag: $TAG"
          fi

      - name: Verify required files and directories
        if: steps.validate.outputs.is_valid == 'true'
        run: |
          echo "üîç Verifying distribution contents..."

          # Check directories
          for dir in .scripts bin docs demos; do
            if [ ! -d "$dir" ]; then
              echo "‚ùå ERROR: Directory $dir not found"
              exit 1
            fi
            echo "‚úÖ Directory: $dir"
          done

          # Check files
          for file in README.md LICENSE; do
            if [ ! -f "$file" ]; then
              echo "‚ùå ERROR: File $file not found"
              exit 1
            fi
            echo "‚úÖ File: $file"
          done

          echo "‚úÖ All required files and directories present"

      - name: Create distribution archive
        if: steps.validate.outputs.is_valid == 'true'
        id: archive
        run: |
          ARCHIVE_NAME="e-bash.${{ steps.version.outputs.version }}.zip"
          echo "üì¶ Creating distribution archive: $ARCHIVE_NAME"

          # Create ZIP archive with specified contents
          zip -r "$ARCHIVE_NAME" \
            .scripts/ \
            bin/ \
            docs/ \
            demos/ \
            README.md \
            LICENSE \
            -x "*.git*" \
            -x "*__pycache__*" \
            -x "*.pyc" \
            -x "*node_modules*" \
            -x "*.DS_Store"

          # Verify archive was created
          if [ ! -f "$ARCHIVE_NAME" ]; then
            echo "‚ùå ERROR: Failed to create archive"
            exit 1
          fi

          # Verify archive integrity
          echo ""
          echo "üîç Verifying archive integrity..."
          if unzip -t "$ARCHIVE_NAME" >/dev/null 2>&1; then
            echo "‚úÖ Archive integrity verified"
          else
            echo "‚ùå ERROR: Archive integrity check failed"
            exit 1
          fi

          # Calculate checksum
          echo ""
          echo "üîê Calculating checksum..."
          CHECKSUM=$(sha256sum "$ARCHIVE_NAME" | cut -d' ' -f1)
          echo "SHA256: $CHECKSUM"

          # Show archive info
          echo ""
          echo "‚úÖ Archive created successfully"
          ls -lh "$ARCHIVE_NAME"
          echo ""
          echo "üìã Archive contents (first 50 files):"
          unzip -l "$ARCHIVE_NAME" | head -n 52

          # Store outputs for next steps
          echo "archive_name=$ARCHIVE_NAME" >> $GITHUB_OUTPUT
          echo "checksum=$CHECKSUM" >> $GITHUB_OUTPUT

      - name: Generate release notes
        if: steps.validate.outputs.is_valid == 'true'
        id: release_notes
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG="${{ steps.version.outputs.tag }}"
          COMMIT_SHA="${{ github.sha }}"
          CHECKSUM="${{ steps.archive.outputs.checksum }}"
          ARCHIVE_NAME="${{ steps.archive.outputs.archive_name }}"

          # Create release notes
          cat > release_notes.md << EOF
          ## e-bash ${VERSION}

          Distribution package for e-bash version ${VERSION}.

          **Commit:** \`${COMMIT_SHA:0:7}\` ([view full commit](https://github.com/OleksandrKucherenko/e-bash/commit/${COMMIT_SHA}))

          ### üîê Integrity Verification

          \`\`\`bash
          # SHA256 Checksum
          ${CHECKSUM}  ${ARCHIVE_NAME}

          # Verify after download
          echo "${CHECKSUM}  ${ARCHIVE_NAME}" | sha256sum -c
          \`\`\`

          ### üì¶ Installation

          \`\`\`bash
          # Download and extract
          wget https://github.com/OleksandrKucherenko/e-bash/releases/download/${TAG}/e-bash.${VERSION}.zip
          unzip e-bash.${VERSION}.zip -d e-bash

          # Or use the quick install script
          curl -sSL https://git.new/e-bash | bash -s --
          \`\`\`

          ### üìÇ Package Contents

          - \`.scripts/\` - Core library functions (16 modules)
          - \`bin/\` - Standalone tools and scripts (11 executables)
          - \`docs/\` - Comprehensive documentation
          - \`demos/\` - Demo scripts showing usage patterns
          - \`README.md\` - Project documentation
          - \`LICENSE\` - MIT License

          ### üîó Resources

          - **Repository:** https://github.com/OleksandrKucherenko/e-bash
          - **Documentation:** https://github.com/OleksandrKucherenko/e-bash/tree/master/docs
          - **Issues:** https://github.com/OleksandrKucherenko/e-bash/issues

          ---

          For detailed changelog, see [CHANGELOG.md](https://github.com/OleksandrKucherenko/e-bash/blob/master/CHANGELOG.md)
          EOF

          echo "‚úÖ Release notes generated"
          cat release_notes.md

      - name: Create GitHub Release
        if: steps.validate.outputs.is_valid == 'true'
        id: create_release
        uses: softprops/action-gh-release@v2
        with:
          name: "e-bash ${{ steps.version.outputs.version }}"
          body_path: release_notes.md
          files: ${{ steps.archive.outputs.archive_name }}
          draft: false
          prerelease: ${{ contains(steps.version.outputs.version, '-') }}
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Release Summary
        if: steps.validate.outputs.is_valid == 'true'
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG="${{ steps.version.outputs.tag }}"
          ARCHIVE_NAME="${{ steps.archive.outputs.archive_name }}"
          CHECKSUM="${{ steps.archive.outputs.checksum }}"
          COMMIT_SHA="${{ github.sha }}"
          RELEASE_URL="https://github.com/${{ github.repository }}/releases/tag/${TAG}"

          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## üéâ Release Created Successfully!

          ### üìã Release Information
          - **Version:** \`${VERSION}\`
          - **Tag:** \`${TAG}\`
          - **Commit:** [\`${COMMIT_SHA:0:7}\`](https://github.com/${{ github.repository }}/commit/${COMMIT_SHA})
          - **Release URL:** ${RELEASE_URL}

          ### üì¶ Distribution Package
          - **Archive:** \`${ARCHIVE_NAME}\`
          - **SHA256:** \`${CHECKSUM}\`

          ### üì• Quick Download
          \`\`\`bash
          wget https://github.com/${{ github.repository }}/releases/download/${TAG}/${ARCHIVE_NAME}
          \`\`\`

          ### ‚úÖ Next Steps
          - View the release: ${RELEASE_URL}
          - Verify checksum after download
          - Update documentation if needed

          ---
          üöÄ Distribution package is now available in [GitHub Releases](${RELEASE_URL})
          EOF
