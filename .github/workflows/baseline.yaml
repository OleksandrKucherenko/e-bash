name: "Update Test Timing Baseline"

on:
  workflow_dispatch:
  schedule:
    # Weekly (Monday 04:00 UTC)
    - cron: "0 4 * * 1"
  # Uncomment if you want to be able to run baseline generation via specially named branch.
  # That can be used for testing of new pipeline code changes, without merging them into main.
  #push:
  #  branches: [junit-baseline-pipeline]

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: test-timing-baseline
  cancel-in-progress: false

env:
  SHELLSPEC_VERSION: 0.28.1
  TERM: xterm-256color
  HOMEBREW_NO_AUTO_UPDATE: 1
  HOMEBREW_NO_INSTALL_CLEANUP: 1
  HOMEBREW_NO_ENV_HINTS: 1
  # Enable CI auto-install mode for dependencies
  CI_E_BASH_INSTALL_DEPENDENCIES: 1

jobs:
  baseline-linux:
    name: "Generate baseline (Linux)"
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout Code with full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0   # Full history needed for git-dependent tests
          fetch-tags: true # Required for tests that check git tags

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Detect Homebrew Path
        id: brew_path
        shell: bash
        run: |
          if [[ "$RUNNER_OS" == "Linux" ]]; then
            echo "path=/home/linuxbrew/.linuxbrew" >> "$GITHUB_OUTPUT"
            echo "cache_dir=/home/runner/.cache/Homebrew" >> "$GITHUB_OUTPUT"
          else
            if [ -d "/opt/homebrew" ]; then
              echo "path=/opt/homebrew" >> "$GITHUB_OUTPUT"
            else
              echo "path=/usr/local/Homebrew" >> "$GITHUB_OUTPUT"
            fi
            echo "cache_dir=$HOME/Library/Caches/Homebrew" >> "$GITHUB_OUTPUT"
          fi

      - name: Verify Files and Folders
        id: hashes
        shell: bash
        run: |
          ls -la .
          pwd
          shasum -a 256 .envrc
          shasum -a 256 .envrc | cut -c1-8
          echo "sha256=$(shasum -a 256 .envrc | cut -c1-8)" >> $GITHUB_OUTPUT

      - name: Check Homebrew cache size
        id: cache_check
        shell: bash
        run: |
          # Check if Homebrew directories exist and their size
          MAX_SIZE_MB=300
          TOTAL_SIZE=0

          if [ -d "${{ steps.brew_path.outputs.path }}" ]; then
            BREW_SIZE=$(du -sm "${{ steps.brew_path.outputs.path }}" 2>/dev/null | cut -f1 || echo "0")
            TOTAL_SIZE=$((TOTAL_SIZE + BREW_SIZE))
            echo "Homebrew path size: ${BREW_SIZE}MB"
          fi

          if [ -d "${{ steps.brew_path.outputs.cache_dir }}" ]; then
            CACHE_SIZE=$(du -sm "${{ steps.brew_path.outputs.cache_dir }}" 2>/dev/null | cut -f1 || echo "0")
            TOTAL_SIZE=$((TOTAL_SIZE + CACHE_SIZE))
            echo "Homebrew cache size: ${CACHE_SIZE}MB"
          fi

          echo "Total Homebrew size: ${TOTAL_SIZE}MB"
          echo "Maximum allowed size: ${MAX_SIZE_MB}MB"

          if [ "$TOTAL_SIZE" -le "$MAX_SIZE_MB" ]; then
            echo "✅ Homebrew size is within limits, caching enabled"
            echo "should_cache=true" >> $GITHUB_OUTPUT
          else
            echo "⚠️  Homebrew size exceeds ${MAX_SIZE_MB}MB, caching disabled to avoid inefficiency"
            echo "should_cache=false" >> $GITHUB_OUTPUT
          fi

      - name: Cache Homebrew packages
        if: steps.cache_check.outputs.should_cache == 'true'
        uses: actions/cache@v4
        with:
          path: |
            ${{ steps.brew_path.outputs.path }}
            ${{ steps.brew_path.outputs.cache_dir }}
          key: brew-${{ runner.os }}-${{ steps.hashes.outputs.sha256 }}
          restore-keys: |
            brew-${{ runner.os }}-

      - name: Setup PATH for local binaries
        run: |
          echo "${HOME}/.local/bin" >> "$GITHUB_PATH"
          mkdir -p "${HOME}/.local/bin"

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y kcov uuid-runtime curl build-essential procps file git

      - name: Install Homebrew (Linux only)
        run: |
          # Check if Homebrew is already installed (from cache)
          if [ ! -x ${{ steps.brew_path.outputs.path }}/bin/brew ]; then
            echo "Installing Homebrew for Linux..."
            NONINTERACTIVE=1 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
          else
            echo "Homebrew found in cache, skipping installation"
          fi

      - name: Add Homebrew to PATH
        shell: bash
        run: |
          echo "${{ steps.brew_path.outputs.path }}/bin" >> $GITHUB_PATH
          # Set up Homebrew environment variables
          eval "$(${{ steps.brew_path.outputs.path }}/bin/brew shellenv)"
          echo "HOMEBREW_PREFIX=${{ steps.brew_path.outputs.path }}" >> "$GITHUB_ENV"
          echo "HOMEBREW_CELLAR=${{ steps.brew_path.outputs.path }}/Cellar" >> "$GITHUB_ENV"
          echo "HOMEBREW_REPOSITORY=${{ steps.brew_path.outputs.path }}/Homebrew" >> "$GITHUB_ENV"

      - name: Install DIRENV and latest BASH
        run: |
          # Install latest bash via Homebrew to ensure consistent behavior across platforms
          brew install bash

          # Install direnv for Ubuntu (must be after Homebrew for dependency order)
          curl -sfL https://direnv.net/install.sh | bash
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"

          # Verify bash version
          echo "Installed bash version: $(brew list --versions bash)"
          echo "System bash version: $BASH_VERSION"
          echo "Brew bash path: $(brew --prefix)/bin/bash"

      - name: Verify installation order and setup
        run: |
          # Verify critical tools are available in correct order
          echo "=== Verifying installation order ==="
          echo "1. Homebrew: $(which brew || echo 'NOT FOUND')"
          echo "2. DIRENV: $(which direnv || echo 'NOT FOUND')"
          echo "3. Homebrew available: $(brew --help >/dev/null 2>&1 && echo 'YES' || echo 'NO')"
          echo "4. DIRENV version: $(direnv version || echo 'FAILED')"

      - name: Setup project dependencies using DIRENV and CI auto-install mode
        run: |
          # Ensure Homebrew is in PATH for this step
          eval "$(${{ steps.brew_path.outputs.path }}/bin/brew shellenv)"
          # Allow .envrc execution and export environment to GitHub Actions
          direnv allow .
          direnv export gha >> "$GITHUB_ENV"
          echo "Dependencies loaded via DIRENV with CI auto-install mode"
          brew cleanup

      - name: Apply ShellSpec Timeout Patch
        shell: bash
        run: |
          # Apply the timeout feature patch to ShellSpec if not already applied
          if ! shellspec --help 2>/dev/null | grep -q -- '--timeout'; then
            echo "Applying ShellSpec timeout patch..."
            chmod +x patches/apply.sh
            ./patches/apply.sh
          else
            echo "ShellSpec timeout patch already applied"
          fi
          # Verify patch is applied
          shellspec --help | grep -A 2 timeout

      - name: Run full ShellSpec suite (with coverage)
        shell: bash
        run: |
          set -euo pipefail
          rm -rf report coverage || true

          set -o pipefail
          shellspec --kcov 2>&1 | tee /tmp/test_output.txt || {
            exit_code=${PIPESTATUS[0]}
            echo "Shellspec exited with code $exit_code, checking if tests actually passed..."

            passed_tests=$(grep -c "^ok " /tmp/test_output.txt || true)
            failed_tests=$(grep -c "^not ok " /tmp/test_output.txt || true)
            has_summary=$(grep -q "examples, .* failures" /tmp/test_output.txt && echo "yes" || echo "no")

            if [ "$passed_tests" -gt 0 ] && [ "$failed_tests" -eq 0 ] && [ "$has_summary" = "yes" ]; then
              echo "✅ All $passed_tests tests passed (0 failures) - ignoring shellspec exit code bug"
              exit 0
            else
              echo "❌ Tests actually failed or incomplete"
              echo "   Passed: $passed_tests, Failed: $failed_tests, Has summary: $has_summary"
              exit 1
            fi
          }

      - name: Create baseline files (Linux)
        shell: bash
        run: |
          set -euo pipefail
          rm -rf .github/data/linux
          mkdir -p .github/data/linux/report

          mapfile -t XML_FILES < <(find report -type f -name '*.xml' -print | sort)
          if [ "${#XML_FILES[@]}" -eq 0 ]; then
            echo "No JUnit XML files found in report/; cannot generate baseline."
            exit 1
          fi
          bun .github/scripts/junit/src/sanitize-junit-xml.ts .github/data/linux/report/baseline.xml "${XML_FILES[@]}"
          bun .github/scripts/junit/src/parse-test-timings.ts .github/data/linux/test-timings.json .github/data/linux/report/baseline.xml --granularity=example
          bun .github/scripts/junit/src/add-lineno-to-timings.ts .github/data/linux/test-timings.json .github/data/linux/test-timings.json.tmp
          mv .github/data/linux/test-timings.json.tmp .github/data/linux/test-timings.json

      - name: Upload baseline artifact (Linux)
        uses: actions/upload-artifact@v4
        with:
          name: baseline-linux
          path: .github/data/linux
          if-no-files-found: error
          retention-days: 30

  baseline-macos:
    name: "Generate baseline (macOS)"
    runs-on: macos-latest
    steps:
      - name: Checkout Code with full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0   # Full history needed for git-dependent tests
          fetch-tags: true # Required for tests that check git tags

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Detect Homebrew Path
        id: brew_path
        shell: bash
        run: |
          if [[ "$RUNNER_OS" == "Linux" ]]; then
            echo "path=/home/linuxbrew/.linuxbrew" >> "$GITHUB_OUTPUT"
            echo "cache_dir=/home/runner/.cache/Homebrew" >> "$GITHUB_OUTPUT"
          else
            if [ -d "/opt/homebrew" ]; then
              echo "path=/opt/homebrew" >> "$GITHUB_OUTPUT"
            else
              echo "path=/usr/local/Homebrew" >> "$GITHUB_OUTPUT"
            fi
            echo "cache_dir=$HOME/Library/Caches/Homebrew" >> "$GITHUB_OUTPUT"
          fi

      - name: Verify Files and Folders
        id: hashes
        shell: bash
        run: |
          ls -la .
          pwd
          shasum -a 256 .envrc
          shasum -a 256 .envrc | cut -c1-8
          echo "sha256=$(shasum -a 256 .envrc | cut -c1-8)" >> $GITHUB_OUTPUT

      - name: Check Homebrew cache size
        id: cache_check
        shell: bash
        run: |
          # Check specific package directories only (not entire Homebrew)
          # Excludes GitHub pre-installed tools: bash, git, git-lfs, jq
          # Excludes optional dev tools: watchman, t-rec, mise
          MAX_SIZE_MB=300
          TOTAL_SIZE=0

          # Only cache packages NOT pre-installed by GitHub Actions
          # Required for CI: direnv, shellspec, GNU tools (grep, sed, awk, coreutils)
          PACKAGES="direnv shellspec grep gnu-sed gawk coreutils"

          echo "=== Checking package sizes (CI-required only) ==="
          for pkg in $PACKAGES; do
            if [ -d "${{ steps.brew_path.outputs.path }}/Cellar/$pkg" ]; then
              PKG_SIZE=$(du -sm "${{ steps.brew_path.outputs.path }}/Cellar/$pkg" 2>/dev/null | cut -f1 || echo "0")
              TOTAL_SIZE=$((TOTAL_SIZE + PKG_SIZE))
              echo "  $pkg: ${PKG_SIZE}MB"
            fi
          done

          # Add small directories (bin, opt, var/homebrew - contain symlinks and metadata)
          echo "=== Checking metadata directories ==="
          for dir in bin opt var/homebrew; do
            if [ -d "${{ steps.brew_path.outputs.path }}/$dir" ]; then
              DIR_SIZE=$(du -sm "${{ steps.brew_path.outputs.path }}/$dir" 2>/dev/null | cut -f1 || echo "0")
              TOTAL_SIZE=$((TOTAL_SIZE + DIR_SIZE))
              echo "  $dir: ${DIR_SIZE}MB"
            fi
          done

          echo ""
          echo "Total package cache size: ${TOTAL_SIZE}MB"
          echo "Maximum allowed size: ${MAX_SIZE_MB}MB"
          echo ""
          echo "ℹ️  Excluded from cache:"
          echo "  - Pre-installed by GitHub: bash, git, git-lfs, jq"
          echo "  - Optional dev tools: watchman, t-rec, mise"

          if [ "$TOTAL_SIZE" -le "$MAX_SIZE_MB" ]; then
            echo "✅ Package cache size is within limits, caching enabled"
            echo "should_cache=true" >> $GITHUB_OUTPUT
          else
            echo "⚠️  Package cache exceeds ${MAX_SIZE_MB}MB, caching disabled"
            echo "should_cache=false" >> $GITHUB_OUTPUT
          fi

      - name: Cache Homebrew packages (CI-required only, excludes pre-installed tools)
        if: steps.cache_check.outputs.should_cache == 'true'
        uses: actions/cache@v4
        with:
          path: |
            ${{ steps.brew_path.outputs.path }}/Cellar/direnv
            ${{ steps.brew_path.outputs.path }}/Cellar/shellspec
            ${{ steps.brew_path.outputs.path }}/Cellar/grep
            ${{ steps.brew_path.outputs.path }}/Cellar/gnu-sed
            ${{ steps.brew_path.outputs.path }}/Cellar/gawk
            ${{ steps.brew_path.outputs.path }}/Cellar/coreutils
            ${{ steps.brew_path.outputs.path }}/bin
            ${{ steps.brew_path.outputs.path }}/opt
            ${{ steps.brew_path.outputs.path }}/var/homebrew
          key: brew-${{ runner.os }}-ci-only-${{ steps.hashes.outputs.sha256 }}
          restore-keys: |
            brew-${{ runner.os }}-ci-only-

      - name: Add Homebrew to PATH
        shell: bash
        run: |
          echo "${{ steps.brew_path.outputs.path }}/bin" >> $GITHUB_PATH

      - name: Setup PATH for local binaries
        run: |
          echo "${HOME}/.local/bin" >> "$GITHUB_PATH"
          mkdir -p "${HOME}/.local/bin"

      - name: Install DIRENV and latest BASH
        run: |
          # Install latest bash to ensure consistent behavior across platforms
          brew install bash

          # Install direnv for macOS
          brew install direnv

          # Verify bash version
          echo "Installed bash version: $(brew list --versions bash)"
          echo "System bash version: $BASH_VERSION"
          echo "Brew bash path: $(brew --prefix)/bin/bash"

      - name: Verify installation order and setup
        run: |
          # Verify critical tools are available in correct order
          echo "=== Verifying installation order ==="
          echo "1. Homebrew: $(which brew || echo 'NOT FOUND')"
          echo "2. DIRENV: $(which direnv || echo 'NOT FOUND')"
          echo "3. Homebrew available: $(brew --help >/dev/null 2>&1 && echo 'YES' || echo 'NO')"
          echo "4. DIRENV version: $(direnv version || echo 'FAILED')"

      - name: Setup project dependencies using DIRENV and CI auto-install mode
        run: |
          # Allow .envrc execution and export environment to GitHub Actions
          direnv allow .
          direnv export gha >> "$GITHUB_ENV"
          echo "Dependencies loaded via DIRENV with CI auto-install mode"
          brew cleanup

      - name: Apply ShellSpec Timeout Patch
        run: |
          # Apply the timeout feature patch to ShellSpec if not already applied
          if ! shellspec --help 2>/dev/null | grep -q -- '--timeout'; then
            echo "Applying ShellSpec timeout patch..."
            chmod +x patches/apply.sh
            ./patches/apply.sh
          else
            echo "ShellSpec timeout patch already applied"
          fi
          # Verify patch is applied
          shellspec --help | grep -A 2 timeout

      - name: Run full ShellSpec suite
        shell: bash
        run: |
          set -euo pipefail
          rm -rf report || true

          set -o pipefail
          shellspec 2>&1 | tee /tmp/test_output.txt || {
            exit_code=${PIPESTATUS[0]}
            echo "Shellspec exited with code $exit_code, checking if tests actually passed..."

            passed_tests=$(grep -c "^ok " /tmp/test_output.txt || true)
            failed_tests=$(grep -c "^not ok " /tmp/test_output.txt || true)
            has_summary=$(grep -q "examples, .* failures" /tmp/test_output.txt && echo "yes" || echo "no")

            if [ "$passed_tests" -gt 0 ] && [ "$failed_tests" -eq 0 ] && [ "$has_summary" = "yes" ]; then
              echo "✅ All $passed_tests tests passed (0 failures) - ignoring shellspec exit code bug"
              exit 0
            else
              echo "❌ Tests actually failed or incomplete"
              echo "   Passed: $passed_tests, Failed: $failed_tests, Has summary: $has_summary"
              exit 1
            fi
          }

      - name: Create baseline files (macOS)
        shell: bash
        run: |
          set -euo pipefail
          rm -rf .github/data/macos
          mkdir -p .github/data/macos/report

          mapfile -t XML_FILES < <(find report -type f -name '*.xml' -print | sort)
          if [ "${#XML_FILES[@]}" -eq 0 ]; then
            echo "No JUnit XML files found in report/; cannot generate baseline."
            exit 1
          fi
          bun .github/scripts/junit/src/sanitize-junit-xml.ts .github/data/macos/report/baseline.xml "${XML_FILES[@]}"
          bun .github/scripts/junit/src/parse-test-timings.ts .github/data/macos/test-timings.json .github/data/macos/report/baseline.xml --granularity=example
          bun .github/scripts/junit/src/add-lineno-to-timings.ts .github/data/macos/test-timings.json .github/data/macos/test-timings.json.tmp
          mv .github/data/macos/test-timings.json.tmp .github/data/macos/test-timings.json

      - name: Upload baseline artifact (macOS)
        uses: actions/upload-artifact@v4
        with:
          name: baseline-macos
          path: .github/data/macos
          if-no-files-found: error
          retention-days: 30

  open-baseline-pr:
    name: "Open baseline update PR"
    runs-on: ubuntu-latest
    needs: [baseline-linux, baseline-macos]
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Download baseline artifact (Linux)
        uses: actions/download-artifact@v4
        with:
          name: baseline-linux
          path: .github/data/linux

      - name: Download baseline artifact (macOS)
        uses: actions/download-artifact@v4
        with:
          name: baseline-macos
          path: .github/data/macos

      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v7
        with:
          commit-message: "new unit tests optimization baseline"
          title: "new unit tests optimization baseline"
          body: |
            Updates the committed unit test optimization baseline used for CI chunking:

            - Linux: `.github/data/linux/`
            - macOS: `.github/data/macos/`

            Generated by the `Update Test Timing Baseline` workflow.
          branch: ci/update-unit-test-optimization-baseline
          delete-branch: true
          add-paths: |
            .github/data/**
