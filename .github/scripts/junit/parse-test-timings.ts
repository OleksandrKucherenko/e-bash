#!/usr/bin/env bun
/**
 * Parse JUnit XML test reports and extract per-file and per-example timing data.
 *
 * This script aggregates test execution times from JUnit XML reports generated by ShellSpec.
 * Supports two granularity levels:
 *   - file: Aggregate timing per spec file (v1.0 format, backward compatible)
 *   - example: Per-example timing with IDs (v2.0 format, for finer chunking)
 *
 * Usage:
 *   bun parse-test-timings.ts <output_json> <junit_xml_files...> [--granularity=file|example]
 *
 * Example:
 *   bun parse-test-timings.ts .test-timings.json report/*.xml
 *   bun parse-test-timings.ts .test-timings.json report/*.xml --granularity=example
 */

import { readFileSync, writeFileSync, existsSync } from "node:fs";
import {
    parseJUnitXMLContent,
    parseJUnitXMLContentExamples,
    mergeTimingsV1,
    mergeExamplesToV2,
    parseGranularity,
    type TimingDataV1,
    type TimingDataV2,
    type ParsedExample,
} from "./lib/parser";

// Output format interfaces
interface OutputDataV1 {
    version: "1.0";
    description: string;
    timings: TimingDataV1;
    total_time: number;
    file_count: number;
    source_files: string[];
}

interface OutputDataV2 {
    version: "2.0";
    granularity: "example";
    description: string;
    timings: TimingDataV2;
    total_time: number;
    file_count: number;
    example_count: number;
    source_files: string[];
}

/**
 * Parse a JUnit XML file and return file-level timings
 */
function parseJUnitXMLFileLevel(xmlFile: string): TimingDataV1 {
    if (!existsSync(xmlFile)) {
        console.error(`Warning: File not found: ${xmlFile}`);
        return {};
    }

    try {
        const xmlContent = readFileSync(xmlFile, "utf-8");
        return parseJUnitXMLContent(xmlContent);
    } catch (error) {
        console.error(`Warning: Failed to parse ${xmlFile}:`, error);
        return {};
    }
}

/**
 * Parse a JUnit XML file and return example-level timings
 */
function parseJUnitXMLExampleLevel(xmlFile: string): ParsedExample[] {
    if (!existsSync(xmlFile)) {
        console.error(`Warning: File not found: ${xmlFile}`);
        return [];
    }

    try {
        const xmlContent = readFileSync(xmlFile, "utf-8");
        return parseJUnitXMLContentExamples(xmlContent);
    } catch (error) {
        console.error(`Warning: Failed to parse ${xmlFile}:`, error);
        return [];
    }
}

async function main() {
    const { granularity, filteredArgs } = parseGranularity(process.argv.slice(2));

    if (filteredArgs.length < 2) {
        console.error(`Usage: bun parse-test-timings.ts <output_json> <junit_xml_files...> [--granularity=file|example]`);
        console.error(`\nExample: bun parse-test-timings.ts .test-timings.json report/*.xml`);
        console.error(`         bun parse-test-timings.ts .test-timings.json report/*.xml --granularity=example`);
        process.exit(1);
    }

    const outputFile = filteredArgs[0];
    const xmlFiles = filteredArgs.slice(1);

    if (xmlFiles.length === 0) {
        console.error("Error: No JUnit XML files provided");
        process.exit(1);
    }

    console.error(`ðŸ“Š Parsing timing data with granularity: ${granularity}`);

    if (granularity === "file") {
        // V1.0 format - file level
        const allTimings: TimingDataV1[] = [];
        for (const xmlFile of xmlFiles) {
            const timings = parseJUnitXMLFileLevel(xmlFile);
            if (Object.keys(timings).length > 0) {
                allTimings.push(timings);
            }
        }

        if (allTimings.length === 0) {
            console.error("Error: No timing data extracted from XML files");
            process.exit(1);
        }

        const merged = mergeTimingsV1(allTimings);
        const totalTime = Object.values(merged).reduce((a, b) => a + b, 0);

        const output: OutputDataV1 = {
            version: "1.0",
            description: "Test execution timings extracted from JUnit XML reports",
            timings: merged,
            total_time: totalTime,
            file_count: Object.keys(merged).length,
            source_files: xmlFiles.map((f) => f.split("/").pop() || f),
        };

        writeFileSync(outputFile, JSON.stringify(output, null, 2));

        console.error(`âœ… Extracted timing data for ${Object.keys(merged).length} spec files`);
        console.error(`ðŸ“Š Total test time: ${totalTime.toFixed(2)}s`);
        console.error(`ðŸ’¾ Saved to: ${outputFile}`);

        // Print summary
        const sorted = Object.entries(merged).sort((a, b) => b[1] - a[1]);
        console.error(`\nðŸ“‹ Top 5 slowest tests:`);
        for (let i = 0; i < Math.min(5, sorted.length); i++) {
            const [file, time] = sorted[i];
            console.error(`  - ${file}: ${time.toFixed(2)}s`);
        }
    } else {
        // V2.0 format - example level
        const allExamples: ParsedExample[][] = [];
        for (const xmlFile of xmlFiles) {
            const examples = parseJUnitXMLExampleLevel(xmlFile);
            if (examples.length > 0) {
                allExamples.push(examples);
            }
        }

        if (allExamples.length === 0) {
            console.error("Error: No example timing data extracted from XML files");
            process.exit(1);
        }

        const merged = mergeExamplesToV2(allExamples);
        const fileCount = Object.keys(merged).length;
        let exampleCount = 0;
        let totalTime = 0;

        for (const fileData of Object.values(merged)) {
            exampleCount += Object.keys(fileData.examples).length;
            totalTime += fileData.total;
        }

        const output: OutputDataV2 = {
            version: "2.0",
            granularity: "example",
            description: "Per-example timing data extracted from JUnit XML reports",
            timings: merged,
            total_time: totalTime,
            file_count: fileCount,
            example_count: exampleCount,
            source_files: xmlFiles.map((f) => f.split("/").pop() || f),
        };

        writeFileSync(outputFile, JSON.stringify(output, null, 2));

        console.error(`âœ… Extracted timing data for ${exampleCount} examples in ${fileCount} spec files`);
        console.error(`ðŸ“Š Total test time: ${totalTime.toFixed(2)}s`);
        console.error(`ðŸ’¾ Saved to: ${outputFile}`);

        // Print summary - slowest examples
        const allExampleTimings: { file: string; id: string; time: number; name: string }[] = [];
        for (const [file, fileData] of Object.entries(merged)) {
            for (const [id, example] of Object.entries(fileData.examples)) {
                allExampleTimings.push({ file, id, time: example.time, name: example.name });
            }
        }
        const sorted = allExampleTimings.sort((a, b) => b.time - a.time);

        console.error(`\nðŸ“‹ Top 5 slowest examples:`);
        for (let i = 0; i < Math.min(5, sorted.length); i++) {
            const { file, id, time, name } = sorted[i];
            const shortName = name.length > 40 ? name.slice(0, 37) + "..." : name;
            console.error(`  - ${file}:${id} (${time.toFixed(3)}s): ${shortName}`);
        }
    }
}

main().catch((error) => {
    console.error("Fatal error:", error);
    process.exit(1);
});
