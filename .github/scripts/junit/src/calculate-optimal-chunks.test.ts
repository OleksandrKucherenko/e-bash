/**
 * Tests for calculate-optimal-chunks.ts
 * Run with: bun test
 */

import { describe, test, expect } from "bun:test";
import { existsSync, readFileSync, rmSync, mkdirSync, writeFileSync, readdirSync } from "node:fs";
import { join, relative } from "node:path";
import { spawnSync } from "node:child_process";

const PROJECT_ROOT = join(import.meta.dir, "../../../..");

function listSpecFiles(projectRoot: string): string[] {
    const specRoot = join(projectRoot, "spec");
    const results: string[] = [];

    function walk(dir: string) {
        for (const entry of readdirSync(dir, { withFileTypes: true })) {
            const fullPath = join(dir, entry.name);
            if (entry.isDirectory()) {
                walk(fullPath);
                continue;
            }
            if (entry.isFile() && entry.name.endsWith("_spec.sh")) {
                const rel = relative(projectRoot, fullPath).replaceAll("\\", "/");
                results.push(rel);
            }
        }
    }

    walk(specRoot);
    return results.sort();
}

describe("calculate-optimal-chunks", () => {
    describe("e2e", () => {
        test("uses baseline timing file when RUNNER_OS=Linux and file exists", () => {
            const specFiles = listSpecFiles(PROJECT_ROOT);
            expect(specFiles.length).toBeGreaterThan(0);

            const baselineDir = join(PROJECT_ROOT, ".github/data/linux");
            const baselineTimingFile = join(baselineDir, "test-timings.json");

            const hadExistingBaseline = existsSync(baselineTimingFile);
            const baselineBackup = hadExistingBaseline ? readFileSync(baselineTimingFile, "utf-8") : null;

            try {
                mkdirSync(baselineDir, { recursive: true });

                const timings: Record<string, number> = {};
                for (const file of specFiles) timings[file] = 1.0;

                writeFileSync(
                    baselineTimingFile,
                    JSON.stringify(
                        {
                            version: "1.0",
                            description: "Baseline timings (generated by tests)",
                            timings,
                            total_time: specFiles.length,
                            file_count: specFiles.length,
                            source_files: ["generated"],
                        },
                        null,
                        2
                    )
                );

                const result = spawnSync("bash", [".github/scripts/chunk-tests.sh", "4", "0"], {
                    cwd: PROJECT_ROOT,
                    encoding: "utf-8",
                    env: { ...process.env, RUNNER_OS: "Linux" },
                });

                expect(result.status).toBe(0);
                expect(result.stderr).toContain("ðŸ“ˆ Timing source:");
                expect(result.stderr).toContain(".github/data/linux/test-timings.json");
            } finally {
                if (hadExistingBaseline && baselineBackup !== null) {
                    writeFileSync(baselineTimingFile, baselineBackup);
                } else if (existsSync(baselineTimingFile)) {
                    rmSync(baselineTimingFile, { force: true });
                }
            }
        });

        test("prints per-chunk estimate and full distribution table to stderr", () => {
            const timingFile = join(PROJECT_ROOT, ".test-timings.json");

            const hadExistingTimingFile = existsSync(timingFile);
            const timingFileBackup = hadExistingTimingFile ? readFileSync(timingFile, "utf-8") : null;

            try {
                const specFiles = listSpecFiles(PROJECT_ROOT);
                expect(specFiles.length).toBeGreaterThan(0);

                const timings: Record<string, number> = {};
                for (const file of specFiles) {
                    timings[file] = 1.0;
                }

                writeFileSync(
                    timingFile,
                    JSON.stringify(
                        {
                            version: "1.0",
                            description: "Test timings (generated by tests)",
                            timings,
                            total_time: specFiles.length,
                            file_count: specFiles.length,
                            source_files: ["generated"],
                        },
                        null,
                        2
                    )
                );

                const result = spawnSync(
                    "bash",
                    [".github/scripts/chunk-tests.sh", "4", "0", "--granularity=file"],
                    { cwd: PROJECT_ROOT, encoding: "utf-8" }
                );

                expect(result.status).toBe(0);
                expect(result.stderr).toContain("â±ï¸");
                expect(result.stderr).toContain("ðŸ“Š Chunk distribution");
            } finally {
                if (hadExistingTimingFile && timingFileBackup !== null) {
                    writeFileSync(timingFile, timingFileBackup);
                } else if (existsSync(timingFile)) {
                    rmSync(timingFile, { force: true });
                }
            }
        });

        test("runs directly with bun and correct parameters", () => {
            const timingFile = join(PROJECT_ROOT, ".test-timings.json");
            const hadExistingTimingFile = existsSync(timingFile);
            const timingFileBackup = hadExistingTimingFile ? readFileSync(timingFile, "utf-8") : null;

            try {
                const specFiles = listSpecFiles(PROJECT_ROOT);
                expect(specFiles.length).toBeGreaterThan(0);

                const timings: Record<string, number> = {};
                for (const file of specFiles) {
                    timings[file] = 1.0;
                }

                writeFileSync(
                    timingFile,
                    JSON.stringify({
                        version: "1.0",
                        description: "Test timings",
                        timings,
                        total_time: specFiles.length,
                        file_count: specFiles.length,
                        source_files: ["generated"],
                    })
                );

                const result = spawnSync(
                    "bun",
                    [".github/scripts/junit/src/calculate-optimal-chunks.ts", timingFile, "2", "0"],
                    { cwd: PROJECT_ROOT, encoding: "utf-8" }
                );

                expect(result.status).toBe(0);
                expect(result.stdout.trim().length).toBeGreaterThan(0);
            } finally {
                if (hadExistingTimingFile && timingFileBackup !== null) {
                    writeFileSync(timingFile, timingFileBackup);
                } else if (existsSync(timingFile)) {
                    rmSync(timingFile, { force: true });
                }
            }
        });
    });
});
